#!/usr/bin/env python3

from os import path
import os
import re
import subprocess
import sys

TESTDIR = path.realpath(path.dirname(__file__))

if "LIBALLOCS_BASE" in os.environ:
    LIBALLOCS_BASE = os.environ["LIBALLOCS_BASE"]
else:
    LIBALLOCS_BASE = path.join(TESTDIR, "../crunch/liballocs")
LIBALLOCS_BASE = path.realpath(LIBALLOCS_BASE)

if "LIBCRUNCH_BASE" in os.environ:
    LIBCRUNCH_BASE = os.environ["LIBCRUNCH_BASE"]
else:
    LIBCRUNCH_BASE = path.join(LIBALLOCS_BASE, "../libcrunch")
LIBCRUNCH_BASE = path.realpath(LIBCRUNCH_BASE)

CLEAN_EXTS = ["-allocsites.c", "-allocsites.so", "-types.c", "-types.c.log.gz",
              "-types.so", ".allocs", ".allocs.rej", ".allocstubs.c",
              ".allocstubs.i", ".allocstubs.o", ".cil.c", ".cil.i", ".cil.s",
              ".i", ".i.allocs", ".makelog", ".o", ".o.fixuplog", ".objallocs",
              ".s", ".srcallocs", ".srcallocs.rej"]

DEFAULT_SUMMARY_VALUE = 0

def runWithEnv(cmd, env = {}):
    assigns = ["%s='%s'" % (e, env[e]) for e in env]
    print(" ".join(assigns + cmd))
    wholeEnv = dict(os.environ)
    wholeEnv.update(env)
    proc = subprocess.Popen(cmd, stdout = subprocess.PIPE,
                            stderr =  subprocess.PIPE, env = wholeEnv)
    (stdout, stderr) = proc.communicate()
    returncode = proc.wait()

    stdout = stdout.decode()
    stderr = stderr.decode()

    print("Command exited with status", returncode, ":")
    print("   ", " ".join(assigns + cmd))
    print("stdout:")
    print(stdout)
    print("\nstderr:")
    print(stderr)

    return (returncode, stdout, stderr)

def parseSummaryLine(line):
    found = False
    ret = {}
    def check(name, match):
        nonlocal found, ret
        if found: # Avoid rechecking once we've found a match for this line
            return
        m = re.match(match + ":?\\s+([0-9]+)", line)
        if m:
            found = True
            ret = {name: int(m.group(1))}

    # Crunch summary outputs
    check("c.begun", "checks begun")
    check("c.aborted_typename", "checks aborted for bad typename")
    check("c.remaining", "checks remaining")
    check("c.lazy_heap", "of which did lazy heap type assignment")
    check("c.failed_alloc", "checks failed inside allocation functions")
    check("c.failed_other", "checks failed otherwise")
    check("c.failed_suppression", "of which user suppression list matched")
    check("c.nontriv", "checks nontrivially passed")
    check("c.hit_cache", "of which hit __is_a cache")

    # Allocs summary outputs
    check("a.abort_heap", "queries aborted for unindexed heap")
    check("a.abort_stack", "queries aborted for unknown stackframes")
    check("a.abort_static", "queries aborted for unknown static obj")
    check("a.abort_storage", "queries aborted for unknown storage")
    check("a.heap", "queries handled by heap case")
    check("a.stack", "queries handled by stack case")
    check("a.static", "queries handled by static case")

    return ret

# Parse the summary generated by libcrunch and liballocs
def parseSummary(output):
    lines = output.splitlines()
    ret = {}
    for l in lines:
        ret.update(parseSummaryLine(l.strip()))
    return ret

class Test:
    def run(self):
        self.clean()

        cmdout = runWithEnv(self.getBuildCmd(), self.getBuildEnv())
        if cmdout[0] != 0: # Return status
            return cmdout[0]

        cmdout = runWithEnv(self.getRunCmd(), self.getRunEnv())
        self.actualSummary = parseSummary(cmdout[2])
        return cmdout[0]

    def checkSummary(self):
        passed = True
        for key in self.correctSummary:
            if key not in self.actualSummary:
                print("Error: Summary value %s not reported, should be %d" %
                        (key, self.correctSummary[key]))
                passed = False
                continue
            if self.correctSummary[key] != self.actualSummary[key]:
                print("Error: Summary value %s should be '%s', got '%s'" %
                      (key, self.correctSummary[key], self.actualSummary[key]))
                passed = False

        # Everything else should be zero
        for key in self.actualSummary:
            if key not in self.correctSummary:
                if self.actualSummary[key] != DEFAULT_SUMMARY_VALUE:
                    print("Error: Summary value %s should be '%s', got '%s'" %
                          (key, DEFAULT_SUMMARY_VALUE,
                           self.actualSummary[key]))
                    passed = False
        return passed

    def getCleanFiles(self):
        return []

    def getBuildEnv(self):
        return {}

    def getRunEnv(self):
        return {}

    def clean(self):
        for f in self.getCleanFiles():
            if path.exists(f):
                os.unlink(f)

class AllocsTest(Test):
    def __init__(self, fname, buildEnv = {}, runEnv = {},
                 fail = False, flags = [], summary = {}):
        self.testName = path.splitext(fname)[0]
        self.src_fname = path.realpath(path.join(TESTDIR, fname))
        self.out_fname = path.splitext(self.src_fname)[0]
        self.buildEnv = buildEnv
        self.runEnv = runEnv
        self.shouldFail = fail
        self.flags = flags
        self.correctSummary = summary

    def getCompiler(self):
        return "clang_allocscc"

    def getName(self):
        return self.testName

    def getBuildCmd(self):
        cmd = [self.getCompiler()]
        cmd += ["-std=c99", "-DUSE_STARTUP_BRK"]
        cmd += self.flags
        cmd += [self.src_fname, "-o", self.out_fname]
        return cmd

    def getBuildEnv(self):
        return self.buildEnv

    def getRunEnv(self):
        liballocs = path.join(LIBALLOCS_BASE, "lib/liballocs_preload.so")
        self.runEnv["LD_PRELOAD"] = path.realpath(liballocs)
        return self.runEnv

    def getRunCmd(self):
        return [self.out_fname]

    def getCleanFiles(self):
        files = [self.out_fname + e for e in CLEAN_EXTS]
        files += [path.splitext(self.src_fname)[0] + e for e in CLEAN_EXTS]
        files += [self.out_fname]

        if "ALLOCSITES_BASE" in os.environ:
            sites = os.environ["ALLOCSITES_BASE"]
        else:
            sites = "/usr/lib/allocsites"
        sites = path.realpath(sites)
        sites = sites + path.realpath(self.out_fname)
        files += [sites + e for e in CLEAN_EXTS]

        return files

class StockAllocsTest(AllocsTest):
    def getBuildCmd(self):
        cmd = AllocsTest.getBuildCmd(self)
        # Without this argument there are "undefined reference to
        # `local_accessors'" errors.
        cmd = [cmd[0], "-gstrict-dwarf"] + cmd[1:]
        return cmd

    def getCompiler(self):
        return "allocscc"

    def getName(self):
        return "stock/" + AllocsTest.getName(self)

class CrunchTest(AllocsTest):
    def getCompiler(self):
        return "clang_crunchcc"

    def getBuildCmd(self):
        cmd = [self.getCompiler()]
        cmd += ["-D_GNU_SOURCE", "-std=c99", "-DUSE_STARTUP_BRK"]
        cmd += ["-I" + path.join(LIBCRUNCH_BASE, "include")]
        cmd += ["-I" + path.join(LIBALLOCS_BASE, "include")]
        cmd += self.flags
        cmd += [self.src_fname, "-o", self.out_fname]
        return cmd

    def getRunEnv(self):
        liballocs = path.join(LIBCRUNCH_BASE, "lib/libcrunch_preload.so")
        self.runEnv["LD_PRELOAD"] = path.realpath(liballocs)
        return self.runEnv

class StockCrunchTest(CrunchTest):
    def getBuildCmd(self):
        cmd = CrunchTest.getBuildCmd(self)
        cmd = [cmd[0], "-gstrict-dwarf"] + cmd[1:]
        return cmd

    def getCompiler(self):
        return "crunchcc"

    def getName(self):
        return "stock/" + CrunchTest.getName(self)

def register_tests():
    tests = {}
    def add(t):
        assert isinstance(t, Test)
        name = t.getName()
        if name in tests:
            print("Error: Test '%s' already exists." % name)
        else:
            tests[t.getName()] = t

    def addAllocsTest(t, summary = {}):
        add(AllocsTest(t, summary = summary))
        add(StockAllocsTest(t, summary = summary))

    def addCrunchTest(t, buildEnv = {}, runEnv = {},
                      fail = False, flags = [], summary = {}):
        add(CrunchTest(t, buildEnv = buildEnv, runEnv = runEnv,
                       fail = fail, flags = flags, summary = summary))
        add(StockCrunchTest(t, buildEnv = buildEnv, runEnv = runEnv,
                            fail = fail, flags = flags, summary = summary))

    addAllocsTest("allocs/offsetof_composite.c", summary = {"a.heap": 1})
    addAllocsTest("allocs/offsetof_simple.c", summary = {"a.heap": 1})
    addAllocsTest("allocs/simple.c", summary = {"a.heap": 1})

    addCrunchTest("crunch/array.c",
                  summary = {"c.begun": 2, "c.remaining": 2, "c.nontriv": 2,
                             "a.static": 2})
    addCrunchTest("crunch/function_refines.c",
                  summary = {"c.remaining": 1, "c.nontriv": 1, "a.static": 1,
                             "c.begun": 1})
    addCrunchTest("crunch/funptr.c",
                  buildEnv = {"LIBCRUNCH_SLOPPY_FUNCTION_POINTERS": "1"},
                  summary = {"c.begun": 2, "c.remaining": 1, "a.static": 1,
                  "a.abort_stack": 1, "a.abort_storage": 1, "a.stack": 1})
    addCrunchTest("crunch/heap.c",
                  summary = {"a.heap": 1, "c.nontriv": 2, "c.remaining": 2,
                             "c.hit_cache": 1, "c.begun": 2})
    addCrunchTest("crunch/indirect.c", flags = ["-O0"],
                  summary = {"c.begun": 10, "c.nontriv": 10, "a.heap": 5,
                             "c.hit_cache": 5, "c.remaining": 10})
    addCrunchTest("crunch/qualified_char.c", summary = {})
    addCrunchTest("crunch/fail/funptr.c", fail = True,
                  summary = {"c.remaining": 1, "a.static": 1, "c.begun": 1,
                             "c.failed_other": 1})
    addCrunchTest("crunch/fail/va_arg.c", fail = True,
                  summary = {"c.begun": 3, "a.stack": 3, "c.remaining": 3,
                             "a.abort_stack": 3})

    addCrunchTest("crunch/lazy_typing.c",
                  buildEnv = {"LIBCRUNCH_LAZY_HEAP_TYPES": "__PTR_void sockaddr"},
                  runEnv = {"LIBCRUNCH_LAZY_HEAP_TYPES": "__PTR_void sockaddr"},
                  summary = {"c.begun": 2, "c.remaining": 2,
                             "c.lazy_heap": 2, "a.heap": 2})

    addCrunchTest("crunch/like_a.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/pointer_degree.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/random.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/sizeofness.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/stack.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/static.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/stubgen.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/union.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/va_arg.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/void.c",
                  summary = {"c.begun": 1})
    addCrunchTest("crunch/voidptrptr.c",
                  summary = {"c.begun": 1})

    # These two seem to give different results sometimes (even with stock).
    addCrunchTest("crunch/fail/voidptrptr_invalid.c", fail = True,
                  summary = {"a.abort_stack": 4, "a.stack": 4, "c.begun": 4,
                             "c.remaining": 4})
    addCrunchTest("crunch/fail/voidptrptr_strict.c", fail = True,
                  buildEnv = {"LIBCRUNCH_STRICT_GENERIC_POINTERS": "1"},
                  summary = {"c.begun": 2, "a.stack": 2, "c.remaining": 2,
                             "c.nontriv": 0, "a.abort_stack": 2})

    return tests

def zshcomp(tests, prefix = ""):
    tests = list(tests) + ["ALL", "CLEAN"]
    tests.sort()
    for t in tests:
        print(prefix, t)

def helpAndExit(tests):
    print("Usage: %s TEST ..." % sys.argv[0])
    print("Available tests:")
    zshcomp(tests, prefix = "   ")
    sys.exit(0)

def main():
    tests = register_tests()

    if "ZSHCOMP" in sys.argv:
        zshcomp(tests)
        sys.exit(0)

    if "CLEAN" in sys.argv:
        for t in tests:
            tests[t].clean()
        for f in os.listdir(TESTDIR):
            fullpath = path.join(TESTDIR, f)
            print(fullpath)
            for e in CLEAN_EXTS:
                if fullpath.endswith(e) and path.exists(fullpath):
                    os.unlink(fullpath)
        return 0

    testNames = sys.argv[1:]

    if len(testNames) == 0:
        helpAndExit(tests)

    if "ALL" in testNames:
        testNames = list(tests.keys())

    nonexist = 0
    passed = 0
    failed_returncode = 0
    failed_summary = 0
    failedTests = []
    total = len(testNames)

    for tn in testNames:
        if tn in tests:
            T = tests[tn]
            if T.run() != 0:
                failed_returncode += 1
                failedTests += [tn]
            else:
                if not T.checkSummary():
                    failed_summary += 1
                    failedTests += [tn]
                else:
                    passed += 1
        else:
            print("Error: No such test: \'" + tn + "\'")
            nonexist += 1

    print()
    print("Summary:")
    print("    Passed              :", passed)
    print("    Failed (returncode) :", failed_returncode)
    print("    Failed (summary)    :", failed_summary)
    print("    Invalid             :", nonexist)
    print("    Total               :", total)

    if failed_returncode + failed_summary > 0:
        print("Failed tests:", " ".join(failedTests))

if __name__ == "__main__":
    main()
